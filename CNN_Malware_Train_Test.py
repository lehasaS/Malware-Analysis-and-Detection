from inspect import ArgSpec
import torch
import numpy as np
import torch.nn as nn
import torch.optim as optim
from data_loaders import *
from CNN_Models import *
from metrics import *
import matplotlib.pyplot as plt
import argparse

def train(model_name, batch_size, dropout, epochs, image_size, learning_rate):
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        
        if(model_name == "Model_One"):
                network = MalCnnOne(dropout, image_size).to(device)
        else:
                network = MalCnnTwo(dropout, image_size).to(device)
                
        criterion = nn.CrossEntropyLoss()
        train_loader, valid_loader = get_image_data_train_val_loaders(image_size, batch_size)

        optimizer = optim.Adam(network.parameters(), lr=learning_rate)

        valid_loss_min = np.Inf # track change in validation loss
        for epoch in range(epochs):
                train_total_loss = 0
                train_loss=0
                ###################
                # train the model #
                ###################
                network.train()
                for images, labels in train_loader:
                        images, labels = images.to(device), labels.to(device)
                        optimizer.zero_grad()
                        output = network(images)
                        
                        loss = criterion(output, labels)
                        loss.backward()

                        optimizer.step()
                        train_loss += loss.item()     
                        
                        
                ######################    
                # validate the model #
                ######################
                valid_total_loss = 0
                valid_loss = 0
                network.eval()
                for images, labels in valid_loader:
                        images,labels = images.to(device),labels.to(device)
                        output = network(images)
                        loss = criterion(output, labels)
                        
                        valid_loss += loss.item()
                
                train_total_loss = train_loss/len(train_loader.dataset)
                valid_total_loss = valid_loss/len(valid_loader.dataset)
                
                # print training/validation statistics 
                print("Epoch:{}/{} \t average training loss:{:.4f} average validation loss:{:.4f}".format(epoch + 1, 30,
                                                                                train_total_loss,
                                                                                valid_total_loss))
                
                # save model if validation loss has decreased
                if valid_loss <= valid_loss_min:
                        print('Validation loss decreased ({:.6f} --> {:.6f}).  Saving model ...'.format(valid_loss_min, valid_loss))
                        torch.save(network.state_dict(), 'Mal_CNN_Detect_{}.pt'.format(model_name))
                        valid_loss_min = valid_loss
        print("==================== Trained Model Saved ====================")

def load_model(model_name):
        model=None
        if model_name == "Model_One":
                model = MalCnnOne()
                model.load_state_dict(torch.load('Mal_CNN_Detect_Model_One.pt'))
        else:
                model = MalCnnTwo()
                model.load_state_dict(torch.load('Mal_CNN_Detect_Model_Two.pt'))
        
        return model


def test_model(image_size, batch_size, model_name):
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        test_loss = 0.0
        accuracy = 0.0
        test_losses = []

        test_loader = get_image_data_test_loader(image_size, batch_size)
        criterion = nn.CrossEntropyLoss()

        model = load_model(model_name).to(device)

        with torch.no_grad():
            model.eval()
            for images, labels in test_loader:
                images,labels = images.to(device),labels.to(device)
                output = model(images)
                test_loss += criterion(output, labels)
                
                ps = torch.exp(output)
                top_p, top_class = ps.topk(1, dim=1)
                equals = top_class == labels.view(*top_class.shape)
                accuracy += torch.mean(equals.type(torch.FloatTensor))
        test_losses.append(test_loss/len(test_loader))

        print("Test Loss: {:.3f}.. ".format(test_losses[-1]),
              "Test Accuracy: {:.3f}".format((accuracy/len(test_loader))*100))
        
        plt.plot(test_losses, label='Validation loss')
        plt.legend(frameon=False)
        plt.savefig('test_losses_{}.png'.format(model_name))


def main(task, model_name):
        if task=="train":
                if model_name=="Model_One":
                        train("Model_One", 128, 0.5, 30, 256, 0.0001)
                else:
                        train("Model_Two", 128, 0.5, 40, 64, 0.0001)
        elif task=="test":
                if model_name=="Model_One":
                        test_model(256, 128, model_name)
                else:
                        test_model(64, 128, model_name)

if __name__ == '__main__':
        parser = argparse.ArgumentParser(prog='CNN_Malware_Train_Test.py', description="Trains and Tests CNN classifiers")
        group = parser.add_mutually_exclusive_group()

        group.add_argument('--train', action='store_true')
        group.add_argument('--test', action='store_true')

        parser.add_argument('one', type=str, required=True, help='This command executes training of model one')
        parser.add_argument('two', type=str, required=True, help='This command executes training of model two')
        args = parser.parse_args()

        if args.train:
                if args.one=="Model One":
                        main("train", "Model_One")
                elif args.one=="Model Two":
                        main("train", "Model_One")
        if args.test:
                if args.one=="Model One":
                        main("test", "Model_One")
                elif args.one=="Model Two":
                        main("test", "Model_Two")
                