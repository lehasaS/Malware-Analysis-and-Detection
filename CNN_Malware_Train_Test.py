from inspect import ArgSpec
import torch
import torch.nn as nn
import numpy as np
import torch.nn as nn
import torch.optim as optim
from data_loaders import *
from CNN_Models import *
from metrics import *
import matplotlib.pyplot as plt
import argparse

def train(model_name, batch_size, dropout, epochs, image_size, learning_rate):
        device = get_device()

        if(model_name == "Model_One"):
                network = MalCnnOne(dropout, image_size).to(device)
        elif(model_name == "Model_Two"):
                network = MalCnnTwo(dropout, image_size).to(device)
                
        optimizer = optim.Adam(network.parameters(), lr=learning_rate, weight_decay=5e-4)
                
        criterion = nn.CrossEntropyLoss()
        train_loader, valid_loader = get_image_data_train_val_loaders(image_size, batch_size)

        train_losses=[]
        validation_losses=[]

        valid_loss_min = np.Inf # track change in validation loss
        for epoch in range(epochs):
                train_total_loss = 0.0
                train_loss=0.0
                ###################
                # train the model #
                ###################
                network.train()
                for images, labels in train_loader:
                        images, labels = to_device(images, device), to_device(labels, device)
                        optimizer.zero_grad()
                        output = network(images)
                        
                        loss = criterion(output, labels)
                        loss.backward()

                        optimizer.step()
                        train_loss += loss.item()     
                        
                        
                ######################    
                # validate the model #
                ######################
                valid_total_loss = 0.0
                valid_loss = 0.0
                network.eval()
                for images, labels in valid_loader:
                        images,labels = to_device(images, device), to_device(labels, device)
                        output = network(images)
                        loss = criterion(output, labels)
                        
                        valid_loss += loss.item()
                
                train_total_loss = train_loss/len(train_loader.dataset)
                valid_total_loss = valid_loss/len(valid_loader.dataset)
                train_losses.append(train_total_loss)
                validation_losses.append(valid_total_loss)
                
                # print training/validation statistics 
                print("Epoch: {}/{} \t Average Training Loss: {:.8f}, Average Validation Loss: {:.8f}".format(epoch + 1, epochs, train_total_loss, valid_total_loss))
                
                # save model if validation loss has decreased
                if valid_loss <= valid_loss_min:
                        print('Validation loss decreased ({:.8f} --> {:.8f}).  Saving model ...'.format(valid_loss_min, valid_loss))
                        torch.save(network.state_dict(), 'train_output/Mal_CNN_Detect_{}.pt'.format(model_name))
                        valid_loss_min = valid_loss
        train_val_loss_plot(train_losses, validation_losses, model_name)
        print("==================== Trained Model Saved ====================")

def load_model(model_name):
        model=None
        if model_name == "Model_One":
                model = MalCnnOne()
                model.load_state_dict(torch.load('train_output/Mal_CNN_Detect_Model_One.pt'))
        else:
                model = MalCnnTwo()
                model.load_state_dict(torch.load('train_output/Mal_CNN_Detect_Model_Two.pt'))
        
        return model


def test_model(image_size, batch_size, model_name):
        devices = get_device()
        test_loss = 0.0
        accuracy = 0.0
        test_losses = []

        test_loader = get_image_data_test_loader(image_size, batch_size)
        criterion = nn.CrossEntropyLoss()

        model = load_model(model_name).to(devices)

        with torch.no_grad():
            model.eval()
            for images, labels in test_loader:
                images,labels = to_device(images, devices), to_device(labels, devices)
                output = model(images)
                loss = criterion(output, labels)
                test_loss += loss.item()
                
                ps = torch.exp(output)
                top_p, top_class = ps.topk(1, dim=1)
                equals = top_class == labels.view(*top_class.shape)
                accuracy += torch.mean(equals.type(torch.FloatTensor))
                test_losses.append(test_loss/len(test_loader.dataset))
                print("Test Loss: {:.8f}, Test Accuracy: {:.8f}".format(test_loss, ((accuracy/len(test_loader))*100)))

        test_loss_plot(test_losses, model_name)
        calc_confusion_matrix(test_loader, devices, model, model_name)

def get_device():
    if torch.cuda.is_available():
        return torch.device('cuda')
    else:
        return torch.device('cpu')
    
def to_device(data, device):
    return data.to(device, non_blocking=True)


def main(task, model_name):
        if task=="train":
                if model_name=="Model_One":
                        train("Model_One", 128, 0.5, 30, 256, 0.0001)
                elif model_name=="Model_Two":
                        train("Model_Two", 128, 0.5, 40, 64, 0.0001)
        elif task=="test":
                if model_name=="Model_One":
                        test_model(256, 128, model_name)
                elif model_name=="Model_Two":
                        test_model(64, 128, model_name)

if __name__ == '__main__':
        parser = argparse.ArgumentParser(prog='CNN_Malware_Train_Test.py', description="Trains and Tests CNN classifiers")
        parser.add_argument('--train', type=str)
        parser.add_argument('--test', type=str)
        args = parser.parse_args()

        if args.train=="Model_One":
                main("train", "Model_One")
        elif args.train=="Model_Two":
                main("train", "Model_Two")

        if args.test=="Model_One":
                main("test", "Model_One")
        elif args.test=="Model_Two":
                main("test", "Model_Two")
                
