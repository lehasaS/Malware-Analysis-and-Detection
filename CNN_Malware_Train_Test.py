from inspect import ArgSpec
import torch
import numpy as np
import torch.nn as nn
import torch.optim as optim
from data_loaders import *
from CNN_Models import *
from metrics import *

def train(model_name, batch_size, dropout, epochs, image_size, learning_rate):
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        
        if(model_name == "Model One"):
                network = MalCnnOne(dropout, image_size).to(device)
        else:
                network = MalCnnTwo(dropout, image_size).to(device)
                
        criterion = nn.CrossEntropyLoss()
        train_loader, valid_loader = get_image_data_train_val_loaders(image_size, batch_size)

        optimizer = optim.Adam(network.parameters(), lr=learning_rate)

        valid_loss_min = np.Inf # track change in validation loss
        for epoch in range(epochs):
                train_total_loss = 0
                train_loss=0
                ###################
                # train the model #
                ###################
                network.train()
                for images, labels in train_loader:
                        images, labels = images.to(device), labels.to(device)
                        optimizer.zero_grad()
                        output = network(images)
                        
                        loss = criterion(output, labels)
                        loss.backward()

                        optimizer.step()
                        train_loss += loss.item()     
                        
                        
                ######################    
                # validate the model #
                ######################
                valid_total_loss = 0
                valid_loss = 0
                network.eval()
                for images, labels in valid_loader:
                        images,labels = images.to(device),labels.to(device)
                        output = network(images)
                        loss = criterion(output, labels)
                        
                        valid_loss += loss.item()
                
                train_total_loss = train_loss/len(train_loader.dataset)
                valid_total_loss = valid_loss/len(valid_loader.dataset)
                
                # print training/validation statistics 
                print("Epoch:{}/{} \t average training loss:{:.4f} average validation loss:{:.4f}".format(epoch + 1, 30,
                                                                                train_total_loss,
                                                                                valid_total_loss))
                
                # save model if validation loss has decreased
                if valid_loss <= valid_loss_min:
                        print('Validation loss decreased ({:.6f} --> {:.6f}).  Saving model ...'.format(valid_loss_min, valid_loss))
                        torch.save(network.state_dict(), 'Mal_CNN_Detect_{}.pt'.format(model_name))
                        valid_loss_min = valid_loss
        print("==================== Trained Model Saved ====================")

def load_model(model_name):
        model=None
        if model_name == "Model One":
                model = MalCnnOne(*ArgSpec)
                model.load_state_dict(torch.load('Mal_CNN_Detect_Model One.pt'))
        else:
                model = MalCnnTwo(*ArgSpec)
                model.load_state_dict(torch.load('Mal_CNN_Detect_Model One.pt'))
        
        return model


def test_model(image_size, batch_size, model_name):
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        test_loss = 0.0
        class_correct = list(0. for i in range(2))
        class_total = list(0. for i in range(2))
        test_loader = get_image_data_test_loader(image_size, batch_size)
        criterion = nn.CrossEntropyLoss()
        classes =["Benign", "Malicious"]

        model = load_model(model_name)

        model.eval()
        # iterate over test data
        for images, labels in test_loader:
                images, labels = images.to(device), labels.to(device)
                output = model(images)
                # calculate the batch loss
                loss = criterion(output, labels)
                # update test loss 
                test_loss += loss.item()
                # convert output probabilities to predicted class
                _, pred = torch.max(output, 1)    
                # compare predictions to true label
                correct_tensor = pred.eq(labels.data.view_as(pred))
                correct = np.squeeze(correct_tensor.numpy()) if not torch.cuda.is_available() else np.squeeze(correct_tensor.cpu().numpy())
                # calculate test accuracy for each object class
                for i in range(batch_size):
                        label = labels.data[i]
                        class_correct[label] += correct[i].item()
                        class_total[label] += 1

        # average test loss
        test_loss = test_loss/len(test_loader.dataset)
        print('Test Loss: {:.6f}\n'.format(test_loss))

        calc_confusion_matrix(test_loader, device, model)

        for i in range(2):
                if class_total[i] > 0:
                        print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % (
                        classes[i], 100 * class_correct[i] / class_total[i],
                        np.sum(class_correct[i]), np.sum(class_total[i])))
                else:
                        print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))

        print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (
        100. * np.sum(class_correct) / np.sum(class_total),
        np.sum(class_correct), np.sum(class_total)))
        

def main():
        print("==================== Starting Training for Model One with optimal Hyperparameters ====================")
        train("Model One", 128, 0.5, 30, 256, 0.0001)
        print("==================== Training Done! ==================== ")

        print("==================== Starting Training for Model Two with optimal Hyperparameters ====================")
        train("Model Two", 128, 0.5, 40, 64, 0.0001)
        print("==================== Training Done! ==================== ")

if __name__=="__main__":
        main()